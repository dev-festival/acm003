---
title: "AAP ACM Coverage to Standard"
subtitle: "Implementation of Standards"
author: "Mike"
date: today
format:
  revealjs:
    theme: [default]
    slide-number: true
    embed-resources: true
    preview-links: auto
    navigation-mode: linear
    controls: true
    progress: true
    history: true
    center: true
    transition: slide
    background-transition: fade
    width: 1280
    height: 720
    incremental: false
    smaller: false
    scrollable: false
execute:
  echo: false
  warning: false
---

# Overview {background-color="#1e3a8a"}

## Purpose {.smaller}

Demonstrate implementation of standards from:

::: {.columns}
::: {.column width="60%"}
- [MESD-ACM-0001](https://globalhonda.sharepoint.com/:w:/r/sites/gna00880-08-Reliability/Shared%20Documents/08-%20Reliability/04-ACM/00_Overall%20Documents/05_Frameworks/000%20-%20Standard%20for%20Tracking%20ACM%20Technology%20Application.docx?d=w9b9e0e5d7f2c4fdbb8f5ee2ce4919adb&csf=1&web=1&e=uMqNtS) - Standard for Tracking (Has Monitoring)
- [Draft 001](https://globalhonda.sharepoint.com/:w:/r/sites/gna00880-08-Reliability/Shared%20Documents/08-%20Reliability/04-ACM/00_Overall%20Documents/05_Frameworks/001%20-%20Asset%20Condition%20Monitoring%20Technology%20Application%20Specification.docx?d=wb984d67b7b004337aa6b469a06190d85&csf=1&web=1&e=JHKuoG) - Technology Application (Needs Monitoring)


**Goal:** Compare Coverage Needs vs Coverage Actuals
:::

:::{.column width ="40%"}
```{mermaid}
%%| fig-width: 8
flowchart LR
    A[Has Monitoring] --> C[Coverage Report]
    B[Needs Monitoring] --> C
    
    style A fill:#ffebee
    style B fill:#e8f5e9
    style C fill:#fff4e1
```

::: {.notes}
Two-part analysis: what we NEED to monitor vs what we ARE monitoring
:::

:::

:::



# Data Collection {background-color="#15803d"}

## Has Monitoring: The Challenge {.smaller}

**Key Question:** How do we reliably track what's being monitored?

- Multiple data sources
- Different monitoring technologies
- Disconnected systems
- Need for repeatable assessment


::: {.fragment}
**Solution:** Extract from Maximo using standardized queries
:::

## Data Architecture 

```{mermaid}
%%| fig-width: 12
flowchart LR
    DB1[Disconnected DB]
    DB2[Connectable DB]
    NM[Native Maximo]
    SQL1[SQL Routes]
    SQL2[SQL Meters]
    PY[Python Merge]
    OUT[Monitored List]
    
    DB1 --> SQL1
    DB2 --> SQL1
    DB2 -. API .-> PY
    NM --> SQL2
    SQL1 --> PY
    SQL2 --> PY
    PY --> OUT
    
    class DB1,DB2,NM source
    class SQL1,SQL2 query
    class PY process
    class OUT output
    
    classDef source fill:#e1f5ff
    classDef query fill:#f3e5f5
    classDef process fill:#e8f5e9
    classDef output fill:#fc8a7bff
```

::: {.notes}
Three pathways converge: disconnected databases, connectable databases, and native Maximo meters
:::

# Route-Based Monitoring {background-color="#7c2d12"}

## Connectable Databases {.smaller}

::: {.columns}
::: {.column width="60%"}

```{mermaid}
%%| fig-width: 12
flowchart LR
    DB1[Disconnected DB]
    DB2[Connectable DB]
    NM[Native Maximo]
    SQL1[SQL Routes]
    SQL2[SQL Meters]
    PY[Python Merge]
    OUT[Monitored List]
    
    DB1 --> SQL1
    DB2 --> SQL1
    DB2 -. API .-> PY
    NM --> SQL2
    SQL1 --> PY
    SQL2 --> PY
    PY --> OUT
    
    class DB2,NM source
    class SQL1,SQL2 query
    class PY process
    class OUT output
    class DB1 target
    
    classDef source fill:#e1f5ff
    classDef query fill:#f3e5f5
    classDef process fill:#fff4e1
    classDef output fill:#e8f5e9
    classDef target fill:#fc8a7b,stroke:#b71c1c,stroke-width:3px,color:#ffffff
```
:::


::: {.column width="40%"}
**API-Enabled Systems**

- Waites (Vibration)
- Hydac (Lubrication)
- FLUKE (IR/Other)
- ZDT (Fanuc)

:::
:::

::: {.aside}
If API not available, use Disconnected Database approach
:::

## Disconnected Databases {.smaller}

::: {.columns}
::: {.column width="60%"}
```{mermaid}
%%| fig-width: 12
flowchart LR
    DB1[Disconnected DB]
    DB2[Connectable DB]
    NM[Native Maximo]
    SQL1[SQL Routes]
    SQL2[SQL Meters]
    PY[Python Merge]
    OUT[Monitored List]
    
    DB1 --> SQL1
    DB2 --> SQL1
    DB2 -. API .-> PY
    NM --> SQL2
    SQL1 --> PY
    SQL2 --> PY
    PY --> OUT
    
    class DB1,NM source
    class SQL1,SQL2 query
    class PY process
    class OUT output
    class DB2 target
    
    classDef source fill:#e1f5ff
    classDef query fill:#f3e5f5
    classDef process fill:#fff4e1
    classDef output fill:#e8f5e9
    classDef target fill:#fc8a7b,stroke:#b71c1c,stroke-width:4px,color:#ffffff
```
:::

::: {.column width="40%"}
**Manual Route Coding**

- FLIR (IR)
- MOTION (Vibration)
- ONTrak (Ultrasound)
- AllTest (Motor Current)
- LubeCon (Chain Monitoring)

:::
:::

::: {.fragment}
**Solution:** Standard naming conventions from MESD-ACM-0001
:::

## Route Naming Standard {.smaller}

::: {.columns}
::: {.column width="50%"}
**Standard Convention** (from MESD-ACM-0001)

![Standard Route Coding](/img/acm003_00.png)

Format: `DEPT_TECH_VENDOR - Description`
:::

::: {.column width="50%"}
**Maximo Examples**

![Examples in Maximo](/img/acm003_01.png)

::: {.fragment}
Two underscores + space-space separator
:::
:::
:::

## SQL Routes Query {.smaller}

```{mermaid}
%%| fig-width: 12
flowchart LR
    DB1[Disconnected DB]
    DB2[Connectable DB]
    NM[Native Maximo]
    SQL1[SQL Routes]
    SQL2[SQL Meters]
    PY[Python Merge]
    OUT[Monitored List]
    
    DB1 --> SQL1
    DB2 --> SQL1
    DB2 -. API .-> PY
    NM --> SQL2
    SQL1 --> PY
    SQL2 --> PY
    PY --> OUT
    
    class DB2,DB1,NM source
    class SQL1,SQL2 query
    class PY process
    class OUT output
    class SQL1 target
    
    classDef source fill:#e1f5ff
    classDef query fill:#f3e5f5
    classDef process fill:#fff4e1
    classDef output fill:#e8f5e9
    classDef target fill:#fc8a7b,stroke:#b71c1c,stroke-width:4px,color:#ffffff
```

### Pattern Matching Logic

```sql
WHERE REGEXP_LIKE(ROUTE.DESCRIPTION, '^[A-Z0-9]+_[A-Z0-9]+_[A-Z0-9]+ - .+') 
```

Matches: **THREE_PART_CODE - Some text description**


::: {.aside}
Can be used in Maximo WHERE clause for saved queries
:::

## Complete Routes Query {.smaller .scrollable}

```{python}
#| echo: false
#| output: asis

import os

data_dir = r"C:\Users\VF033899\AppData\Roaming\DBeaverData\workspace6\General\Scripts\maximo-sql-scripts\scripts\projects\102ki-acm-2026"

try:
    with open(os.path.join(data_dir, "acm_assets_routes-coverage.sql"), 'r') as f:
        print(f"```sql\n{f.read()}\n```")
except FileNotFoundError:
    print("```sql\n-- SQL file not found in presentation environment\n-- See documentation for full query\n```")
```

## Routes Query Output {.smaller}

![DBeaver SQL Routes Output](/img/acm003_08.png)

::: {.fragment}
**Next Steps:** Transform into Technology & Vendor columns
:::

## Routes Transformation {auto-animate=true}

### Raw Output → Tech-Vendor Detail

![Tech-Vendor Detail](/img/acm003_10.png)

## Routes Transformation {auto-animate=true}

### Tech-Vendor Detail → Coverage Summary

![Coverage Summary](/img/acm003_09.png)

::: {.fragment}
Pivot to show each asset's technology coverage (Y/N flags)
:::

---

# Routes Coverage Analytics {background-color="#4c1d95"}

## {background-image=".\img\acm003_11.png" background-size="contain"}

::: {.notes}
Technology Coverage by Department
:::

## {background-image=".\img\acm003_12.png" background-size="contain"}

::: {.notes}
Flip perspective: how departments are covered across technologies
:::

---

# Meter-Based Monitoring {background-color="#0c4a6e"}

## Native Maximo Approach {.smaller}

::: {.columns}
::: {.column width="50%"}
![Native Maximo Flow](/img/acm003_06.png)
:::

::: {.column width="50%"}
**Direct Meter Records**

::: {.incremental}
- Readings stored in Maximo
- Direct SQL access
- Simpler than route parsing
- Native asset linkage
:::
:::
:::

## SQL Meters Query {.smaller}

![SQL Meters Flow](/img/acm003_07.png)

**Extract:** Meter Name, Last Reading Date, Asset Number

## Complete Meters Query {.smaller .scrollable}

```{python}
#| echo: false
#| output: asis

import os

data_dir = r"C:\Users\VF033899\AppData\Roaming\DBeaverData\workspace6\General\Scripts\maximo-sql-scripts\scripts\projects\102ki-acm-2026"

try:
    with open(os.path.join(data_dir, "acm_assets_meters-coverage.sql"), 'r') as f:
        print(f"```sql\n{f.read()}\n```")
except FileNotFoundError:
    print("```sql\n-- SQL file not found in presentation environment\n-- See documentation for full query\n```")
```

## Meters Query Results {.smaller}

![Meters Coverage Raw](/img/acm003_13.png)

::: {.fragment}
**Scale:** 24,091 meters applied to 8,223 assets
:::

## Data Quality Assessment {.smaller}

### Three Key Questions

::: {.incremental}
1. Which meters are **active**?
2. How many meters per asset?
3. Does asset qualify as "Has General Metering"?
:::

## Missing Data Analysis {.smaller .scrollable}

| Field | Missing Count | Percentage |
|-------|--------------|------------|
| ASSETNUM | 0 | 0.00% |
| METERNAME | 0 | 0.00% |
| METERTYPE | 0 | 0.00% |
| AVGCALCMETHOD | 19,488 | 80.89% |
| ROLLDOWNSOURCE | 19,570 | 81.23% |
| POINTNUM | 15,171 | 62.97% |
| **LASTREADING** | **5,679** | **23.57%** |
| LASTREADING_DATE | 5,568 | 23.11% |

::: {.fragment}
**Key Finding:** ~23% of meters have no reading date
:::

::: {.notes}
Available for investigation: meters_flagged_null_readings.csv
:::

## Activity Threshold Decision {.smaller}

**Question:** How old can last reading be before asset loses coverage?

::: {.fragment}
```{mermaid}
%%| fig-width: 8
flowchart LR
    A{Within 1 Year?}
    A -->|Yes| B[Has General Meter - Y]
    A -->|No| C[None - N]
    
    style B fill:#e8f5e9
    style C fill:#ffebee
```
:::

::: {.fragment}
**Decision:** 1-year threshold for active monitoring
:::

## Asset-Level Aggregation {.smaller}

![Meter Count Aggregated to Asset](/img/acm003_14.png)

::: {.incremental}
- **Count** of meters per asset
- **Max** last reading date
- Basis for coverage flag
:::

## Coverage Classification {.smaller}

![HAS_GM Column Added](/img/acm003_15.png)

::: {.columns}
::: {.column width="50%"}
**New Columns**

- `READING_WITHIN_1YR`
- `HAS_GM` (Y/N flag)
:::

::: {.column width="50%"}
::: {.fragment}
**Logic:** If max reading within 1 year → Y, else N
:::
:::
:::

---

# Data Integration {background-color="#831843"}

## Python Merge Strategy {.smaller}

::: {.callout-important}
## Documentation In Progress
Detailed merge logic being finalized
:::

::: {.fragment}
**Approach:** Pre-aggregation merge using asset master as single source of truth
:::

## Initial Coverage Results {.smaller}

| Technology | Coverage | Percentage |
|-----------|----------|------------|
| **GM** (General Metering) | 5,005 assets | 60.9% |
| **IR** (Infrared) | 360 assets | 4.4% |
| **UL** (Ultrasound) | 207 assets | 2.5% |
| **VI** (Vibration) | 345 assets | 4.2% |
| **LU** (Lubrication) | 131 assets | 1.6% |
| **MC** (Motor Circuit) | 0 assets | 0.0% |
| **ZD** (Zero Defect) | 86 assets | 1.0% |

::: {.fragment}
**Total Asset Base:** ~8,200 assets
:::

---

# Needs Monitoring {background-color="#713f12"}

## The Complexity Challenge {.smaller}

::: {.incremental}
- Each technology monitors specific **components**
- Each technology targets specific **failure modes**
- Maximo lacks **component-level granularity**
- Need systematic mapping approach
:::

## Solution: Component Mapping {.smaller}

**Reference:** Draft 001 - ACM Technology Application (Table 2)

::: {.fragment}
**Legend:**
- **P** = Primary application
- **S** = Secondary application
:::

## Component to Technology Map {.smaller .scrollable}

```{python}
#| echo: false
#| label: component-map
#| tbl-cap: Component to Technology Map

import pandas as pd

data_dir = r"C:\Users\VF033899\AppData\Roaming\DBeaverData\workspace6\General\Scripts\maximo-sql-scripts\scripts\projects\102ki-acm-2026"

try:
    component_map = pd.read_csv(f"{data_dir}/component_map.csv")
    component_map.style.hide(axis='index')
except FileNotFoundError:
    # Create sample structure if file not found
    sample_data = {
        'Component': ['Bearings', 'Motors', 'Gearboxes', 'Hydraulics'],
        'VI': ['P', 'P', 'P', 'S'],
        'IR': ['S', 'P', 'S', 'P'],
        'UL': ['P', 'S', 'S', 'P'],
        'LU': ['P', 'S', 'P', 'S']
    }
    pd.DataFrame(sample_data).style.hide(axis='index')
```

---

# Next Steps {background-color="#1e3a8a"}

## Coverage Gap Analysis {.smaller}

::: {.incremental}
1. Map asset types to required technologies
2. Compare needs vs actual coverage
3. Identify critical monitoring gaps
4. Prioritize implementation plan
:::

## Documentation & Resources {.smaller}

::: {.columns}
::: {.column width="50%"}
**Related Resources**
- MESD-ACM-0001 Standard
- Draft 001 Tech Specification
- SQL query repository
- Python merge scripts
:::

::: {.column width="50%"}
**Key Contacts**
- Stakeholder: [TBD]
- Team Members: [TBD]
- Technical Support: [TBD]
:::
:::

---

# Questions? {background-color="#1e3a8a"}

## Thank You

**Feedback & Discussion**
